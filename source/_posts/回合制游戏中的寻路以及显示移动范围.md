---
title: 回合制游戏中的寻路以及显示移动范围
date: 2022-06-13 21:43:46
tags: [Unity, A*, BFS]
thumbnail: https://satt.oss-cn-hangzhou.aliyuncs.com/img/20220613220130.png
---

这几天看了[Making a Turn Based Strategy Game in Unity](https://www.youtube.com/watch?v=MNSQWPhalGQ)的视频，打算尝试做一个回合制的游戏。
尽管此前已经写过[A\*算法](https://studyallthetime.com/2021/10/07/A-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0/)了，但是实际创建的时候还是遇到了一些问题。我发现C#中居然没有自带的优先队列。由于不想过度优化（实际上是懒惰），我就放弃了手写一个的打算(希望日后能补上).由于原理不难，我就不贴代码了。还有一个发现就是有关带权A*算法的问题。做一个简单的总结.
``` C#
fScore[neighbour] = tentative_gScore + w * h_Manhattan(neighbour.x, neighbour.y, targetX, targetY);
```
此时，当w = 0时，A*为dijkstra算法。当0 < w < 1时候，A\*算法更像会不注重速度，而是在乎准确性。当w>1的时候，此时的最终路径则不一定是最优的。当w远大于h的时候，A\*就会接近于BFS.

另一个就是当我试图给class重载`==`以及`!=`操作符遇到的一个奇怪的问题.在一开始, 我直接将代码写成如下形式：
``` C#
    public static bool operator ==(Node left, Node right)
    {
        if (left.x == right.x && left.y == right.y)
        {
            return true;
        }
        else return false;
    }
```
但是这种写法，在我使用类似 `node == null`进行判断的时候就会爆空引用。这是合理的，因为此时我的right必然是null。因此，我对原有代码稍作修改，如下所示：
``` C#
    public static bool operator ==(Node left, Node right)
    {
        
        if (left == null)
        {
            if (right == null) return true;
            else return false;
        }
        else
        {
            if (right == null) return false;
            else
            {
                if (left.x == right.x && left.y == right.y)
                {
                    return true;
                }
                else return false;
            }
        }
    }
```

写完后我立刻就发现了问题，显然`left == null` 这句会循环调用我定义的操作符`==`,运行后也果然爆栈了。一番思索过后，我放弃了解决。不过我发现有人也遇到了我类似的问题[一个解决方法](https://blog.csdn.net/poson/article/details/2578362?utm_source=blogxgwz4),虽然使用equals的方法并不优美，但好像也只能这么做了。另一个解决方法是使用`node is object`语句判定。因为所有的类型都继承自object，这种做法显然更加合理.

接下去我来介绍一下如何显示合理的移动范围.Node类的定义以及主要逻辑代码如下所示.
``` C#
public class Node 
{
    public List<Node> neighbours;
    public int x;
    public int y;
    public TileType nodeType;
    public bool isVisited_movementRange;
    public float remainMovement;
    public float DistanceTo(Node n)
    {
        return Vector2.Distance(new Vector2(this.x, this.y), new Vector2(n.x, n.y));
    }
    public Node(int x, int y)
    {
        this.x = x;
        this.y = y;
        this.neighbours = new List<Node>();
    }
}

```

``` C#
void showMovementRange(int x1, int y1)
{
    List<Node> moveRange = new List<Node>();
    for (int x = 0; x < mapSizeX; x++)
    {
        for (int y = 0; y < mapSizeY; y++)
        {
            graph[x, y].isVisited_movementRange = false;
        }
    }
    Node root = graph[x1, y1];
    root.isVisited_movementRange = true;
    root.remainMovement = 5;
    Queue<Node> Q = new Queue<Node>();
    Q.Enqueue(root);
    while (Q.Count > 0)
    {
        Node v = Q.Dequeue();
        foreach (var vn in v.neighbours)
        {
            if (vn.isVisited_movementRange)
                continue;
            if (v.remainMovement - (1 + vn.nodeType.extraCost) >= 0)
            {
                vn.remainMovement = v.remainMovement - (1 + vn.nodeType.extraCost);
                vn.isVisited_movementRange = true;
                moveRange.Add(vn);
                Q.Enqueue(vn);
            }
        }
    }

    foreach (var move in moveRange)
    {
        Debug.Log(move.x + "," +move.y);
    }
    MapUI.instance.showMovementRange(moveRange);

```
代码很简单，效果却不错。
![运动力为5时候的可移动范围](https://satt.oss-cn-hangzhou.aliyuncs.com/img/20220613220130.png)
<center>运动力为5时的移动范围(蓝色方块)</center>

待续